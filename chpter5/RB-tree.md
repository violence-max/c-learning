> 红黑树是一颗二叉平衡搜索树
>   
- 红黑树所必须满足的四个性质：
    1. 每个节点不是红色就是黑色
    2. 根节点是黑色的
    3. 如果一个节点是红色的，那么其子节点的颜色一定是黑色的
    4. 一个节点到尾端（null）的任何路径所经历的黑节点的个数是相等的  
根据规则4，新增节点必须为红色的；根据规则3，新增节点的父节点必须为黑色的。如果新增节点不满足要求，那么必须调整颜色并且旋转树形  
- 红黑树的插入：  
为了方便讨论，我们假设插入的节点为X，且X的插入违反了规则3，即插入节点的父节点为红色的。设X的父节点为P，伯父节点为S，即P的兄弟节点，祖父节点为G，曾祖父节点为GG。则X的颜色为和红色，P的颜色为红色，G的颜色一定为黑色，GG和S的颜色随意。可分为以下四种情况来讨论：  
1. X为外侧插入且S为黑色：这时候只需要以G作为右旋点对P和G进行右旋操作，并且将X的颜色调整为黑色就可以保证规则3和4了（**这种情况如果S有子节点则会打破树的平衡性，然而红黑树对平衡性的要求么有AVL-tree那么高，无所谓，而且搜索平均效率与AVL-tree基本一致**）  
2. X为内侧插入且S为黑色：对于内侧插入需要两次单旋转操作，第一次是以P为左旋点进行左旋操作，并且将X的颜色调整为黑色、G的颜色调整为红色来保证G的左侧满足规则4，但此时G的右侧不满足规则4，而且因为GG的颜色原本可能是红色而出现G和GG两个父子同为红色的情况，因此还需要以G为右旋点对X和G进行一次右旋操作  
3. X为外侧插入且S为红色：以G为右旋点对P和G进行右旋操作，并且将X的颜色调整为黑色即可保证规则4。但若GG是红色的，则出现了父子GG和P同为红色的情况，此时需要以GG为右旋点对P和GG再进行一次右旋操作。恶心的是进行了一次右旋操作以后仍然会有父子同为红色的情况，此时应该继续往上操作直到没有父子同为红色为止  
    现在又有了一种新的说法：只需要修改P和S的颜色为黑色，然后将G的颜色修改为红色，如果GG也是红色的那就继续向上调整。因此外侧插入和内侧插入S为红色的情况都是一致的（这就是在插入之后所说的由上而下的调整程序，我草率了）  
4. X为内侧插入且S为红色：（这种情况比较复杂）先以P为左旋点对P和X进行左旋操作，如果GG为黑色那就 调整结束了，但是如果GG为红色，那么需要以GG为左旋点或者右旋点对P和GG向上持续操作
- 一个由上而下的程序：为了避免状况3和状况4这些父子都为红色的情况，可以在插入节点的过程中设计一个自上而下的程序。假设插入节点A，那么在插入节点A的路径上，如果遇到节点X，其父节点为P，祖父节点为G，伯父节点为S，且X的两个子节点均为红色，那么就将X的颜色修改为红色，X的子节点的颜色修改为黑色。若P的颜色也为红色（S的颜色绝不可能为红色（这里我没有找到一个有效的证明，但是可以知道的是这种情况是不可能发生的，无法有一个合法的插入操作使得P和S同为红色而且P的子树还满足以上条件）），则对X和P进行一次单旋转的操作并且修改颜色。此时X的插入情况就很简单了，要么直接插入，要么插入之后需要进行一次单旋转操作或者进行一次双旋转操作即可
- 红黑树的迭代器的前进和后退的操作：红黑树的迭代器含有一个node节点，其前进和后退的操作是遵守树的中序遍历的规则的。要求红黑树的每个节点经过若干次的前进或者后退操作以后一定可以到达树中的任意一个节点，相当于是一个双向链表了。**这样的设计结构真的很牛逼**，首先需要的是一个header节点当作是树的end()迭代器，header节点的左子节点（mostleft）指向树的第一个节点，即树的最左下角的节点，右子节点（mostright）指向树的最后一个有效节点，每个节点都有parent指针，而header的parent不是别人，就是根节点root本身。而且这样设计本身对于红黑树而言求极值操作仅仅是常数时间的，因为最左节点即为最小值，最右节点即为最大值  
    1. 前进操作：
        1. 如果node存在右子节点，则寻找node→right的最左下角节点即为node的下一个节点
        2. node不存在右子节点，令y为node的parent节点当node为y的右子节点时持续while循环，令node = y，y = y →parent。
        3. 如果此时node的右子节点不为y（node为根节点，且根节点作为树的最后一个节点，此时header的右子节点为node），则y即为所求
        4. 如果此时node的右子节点为y，则此时的node即为所求
    2. 后退操作：
        1. 如果node是红色的（暂时不明白是为什么：现在明白了，红黑树的根节点为黑色，而header节点为红色，因此于根节点区分开来）且node的parent的parent节点就是node本身（对应node为header的且根节点为mostleft的情况），则node的右子节点（mostright）即为所求
        2. 如果node的左子节点存在，则node的左子节点的最右节点即为所求
        3. 令y为node的parent，当node为y的左子节点时不断向上寻找，直到node不为y的左子节点为止，此时的父节点y即为所求。第一个节点的前一个节点即为header
- 红黑树的节点的基本成员和基本操作函数：
1. get_node()：创建一个节点
2. put_node(node)：销毁一个节点
3. create_node(x)：创建一个值为x的节点
4. clone_node(node)：克隆一个值和颜色相同的节点，但是左右孩子为空
5. header：实现技巧；node_count：记录节点个数；key_compare：键值大小比较准则
6. insert_unique(x)：保持节点值的独一无二
7. insert_equal(x)：允许节点值重复
- 红黑树的迭代器架构：
1. _rb_tree_node_base：node的base结构，具有parent，left和right三个指针等基本成员
2. _rb_tree_node：一个红黑树节点，继承其base结构。具有节点值和指向节点的指针
3. _rb_tree_base_iterator：使用node_base的指针，用该指针定义了一个node，以及node的前进和后退等基本操作
4. _rb_tree_iterator：继承其base结构，具有指向node的指针，以及operator的基本操作