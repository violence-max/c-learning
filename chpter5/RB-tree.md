> 红黑树是一颗二叉平衡搜索树
>   
- 红黑树所必须满足的四个性质：
    1. 每个节点不是红色就是黑色
    2. 根节点是黑色的
    3. 如果一个节点是红色的，那么其子节点的颜色一定是黑色的
    4. 一个节点到尾端（null）的任何路径所经历的黑节点的个数是相等的  
根据规则4，新增节点必须为红色的；根据规则3，新增节点的父节点必须为黑色的。如果新增节点不满足要求，那么必须调整颜色并且旋转树形  
- 红黑树的插入：  
为了方便讨论，我们假设插入的节点为X，且X的插入违反了规则3，即插入节点的父节点为红色的。设X的父节点为P，伯父节点为S，即P的兄弟节点，祖父节点为G，曾祖父节点为GG。则X的颜色为和红色，P的颜色为红色，G的颜色一定为黑色，GG和S的颜色随意。可分为以下四种情况来讨论：  
1. X为外侧插入且S为黑色：这时候只需要以G作为右旋点对P和G进行右旋操作，并且将X的颜色调整为黑色就可以保证规则3和4了（**这种情况如果S有子节点则会打破树的平衡性，然而红黑树对平衡性的要求么有AVL-tree那么高，无所谓，而且搜索平均效率与AVL-tree基本一致**）  
2. X为内侧插入且S为黑色：对于内侧插入需要两次单旋转操作，第一次是以P为左旋点进行左旋操作，并且将X的颜色调整为黑色、G的颜色调整为红色来保证G的左侧满足规则4，但此时G的右侧不满足规则4，而且因为GG的颜色原本可能是红色而出现G和GG两个父子同为红色的情况，因此还需要以G为右旋点对X和G进行一次右旋操作  
3. X为外侧插入且S为红色：以G为右旋点对P和G进行右旋操作，并且将X的颜色调整为黑色即可保证规则4。但若GG是红色的，则出现了父子GG和P同为红色的情况，此时需要以GG为右旋点对P和GG再进行一次右旋操作。恶心的是进行了一次右旋操作以后仍然会有父子同为红色的情况，此时应该继续往上操作直到没有父子同为红色为止  
    现在又有了一种新的说法：只需要修改P和S的颜色为黑色，然后将G的颜色修改为红色，如果GG也是红色的那就继续向上调整。因此外侧插入和内侧插入S为红色的情况都是一致的（这就是在插入之后所说的由上而下的调整程序，我草率了）  
4. X为内侧插入且S为红色：（这种情况比较复杂）先以P为左旋点对P和X进行左旋操作，如果GG为黑色那就 调整结束了，但是如果GG为红色，那么需要以GG为左旋点或者右旋点对P和GG向上持续操作
- 一个由上而下的程序：为了避免状况3和状况4这些父子都为红色的情况，可以在插入节点的过程中设计一个自上而下的程序。假设插入节点A，那么在插入节点A的路径上，如果遇到节点X，其父节点为P，祖父节点为G，伯父节点为S，且X的两个子节点均为红色，那么就将X的颜色修改为红色，X的子节点的颜色修改为黑色。若P的颜色也为红色（S的颜色绝不可能为红色（这里我没有找到一个有效的证明，但是可以知道的是这种情况是不可能发生的，无法有一个合法的插入操作使得P和S同为红色而且P的子树还满足以上条件）），则对X和P进行一次单旋转的操作并且修改颜色。此时X的插入情况就很简单了，要么直接插入，要么插入之后需要进行一次单旋转操作或者进行一次双旋转操作即可
- 红黑树的迭代器的前进和后退的操作：红黑树的迭代器含有一个node节点，其前进和后退的操作是遵守树的中序遍历的规则的。要求红黑树的每个节点经过若干次的前进或者后退操作以后一定可以到达树中的任意一个节点，相当于是一个双向链表了。**这样的设计结构真的很牛逼**，首先需要的是一个header节点当作是树的end()迭代器，header节点的左子节点（mostleft）指向树的第一个节点，即树的最左下角的节点，右子节点（mostright）指向树的最后一个有效节点，每个节点都有parent指针，而header的parent不是别人，就是根节点root本身。而且这样设计本身对于红黑树而言求极值操作仅仅是常数时间的，因为最左节点即为最小值，最右节点即为最大值  
    1. 前进操作：
        1. 如果node存在右子节点，则寻找node→right的最左下角节点即为node的下一个节点
        2. node不存在右子节点，令y为node的parent节点当node为y的右子节点时持续while循环，令node = y，y = y →parent。
        3. 如果此时node的右子节点不为y（node为根节点，且根节点作为树的最后一个节点，此时header的右子节点为node），则y即为所求
        4. 如果此时node的右子节点为y，则此时的node即为所求
    2. 后退操作：
        1. 如果node是红色的（暂时不明白是为什么：现在明白了，红黑树的根节点为黑色，而header节点为红色，因此于根节点区分开来）且node的parent的parent节点就是node本身（对应node为header的且根节点为mostleft的情况），则node的右子节点（mostright）即为所求
        2. 如果node的左子节点存在，则node的左子节点的最右节点即为所求
        3. 令y为node的parent，当node为y的左子节点时不断向上寻找，直到node不为y的左子节点为止，此时的父节点y即为所求。第一个节点的前一个节点即为header
- 红黑树的节点的基本成员和基本操作函数：
1. get_node()：创建一个节点
2. put_node(node)：销毁一个节点
3. create_node(x)：创建一个值为x的节点
4. clone_node(node)：克隆一个值和颜色相同的节点，但是左右孩子为空
5. header：实现技巧；node_count：记录节点个数；key_compare：键值大小比较准则
6. insert_unique(x)：保持节点值的独一无二
7. insert_equal(x)：允许节点值重复
- 红黑树的迭代器架构：
1. _rb_tree_node_base：node的base结构，具有parent，left和right三个指针等基本成员
2. _rb_tree_node：一个红黑树节点，继承其base结构。具有节点值和指向节点的指针
3. _rb_tree_base_iterator：使用node_base的指针，用该指针定义了一个node，以及node的前进和后退等基本操作
4. _rb_tree_iterator：继承其base结构，具有指向node的指针，以及operator的基本操作
- 红黑树插入和删除的源码分析：
1. rotate_left_no_parent_fix(p,p_right)：以p为左旋点进行左旋操作，但是不调整p_right的父指针和G的左子节点或者右子节点（p可能是G的左子节点也可能是G的右子节点）：先将p_right_left和p进行连接（记得回马枪操作），再对p和p_right进行连接
2. rotate_left(p,p_right)：先进行一次rotate_left_no_parent_fix操作再调整p_right的父节点和G的孩子节点
3. rotate_right_no_parent_fix(p,p_left)：与1对称
4. rotate_right(p,p_left)：与2一样
5. insert(x)：二叉搜索树插入值为x的节点，作为红黑树插入删除的基础
6. rebalance_after_insertion(header,x)：x为新插入的节点，插入后进行平衡调整的操作：
    1. 新节点的颜色都是红色，故先将p的颜色赋值为红色
    2. 进行while(1)循环，特定条件退出：（退出后需要将根节点赋值为黑色，要保持根节点颜色的正确性）
        1. 如果P为header则说明新插入的节点为root，直接退出
        2. 如果P的颜色为黑色则无需调整，退出
        3. 如果G为header，则表示在root之下插入节点，可以直接退出
        4. 将G的颜色调整为红色（到了这一步说明P的颜色一定为红色，则至少进行一次旋转操作，稍后会看到，无论怎么旋转G的颜色最终都要更改为红色，因此这里提前进行赋值）并且用S记录P的兄弟节点（P为左子节点则S为右子节点P为右子节点则S为左子节点）
        5. 如果S存在且S为红色则将P和S赋值为黑色进行自上而下的操作：将x更改为G（这里就不用把G的颜色由黑色更改为红色了，第4点一开始的操作其实是一个复用操作）  
            否则，则可以进行常规的左左、左右、右右和右左操作：  
        6. 如果P为左子节点，且x为右子节点，则为左右，以P为左旋点对P，x进行一次rotate_left_no_parent_fix操作（不更改x的父节点和G的左子节点是因为在具体的代码实现过程中的一个技巧，左左和左右同在一个if判断语句以内，并且左右的判断在左左之前，因此无论是左左还是左右最终都要以G为右旋点对G和P位置的节点进行一次右旋的操作，注意，这里称为P位置的节点是因为在代码实现过程中因为只是修改节点间指针的指向，因此经过一次rotate_left_no_parent_fix以后x已经移动到了P原来的位置，因此需要间P修改为x再进行之后的操作。在经过一次彻底的右旋操作以后，G的需要改变的左指针指到了P的右子节点，而P的父指针会指向GG，这就是tricky的代码技巧！这就是为什么我要额外分析插入操作的源码的原因！！！）并且将P更新为x，然后以G为右旋点对G和P进行右旋操作即可
        7. 如果P是右子节点与第6点对称
        8. 旋转结束后将P的颜色调整为黑色即可退出while循环
        9. 退出while循环后记得将root的颜色保持为黑色
7. struct data_for_rebalance {node x,node y,node x_parent}：为删除操作记录删除数据的铺垫
8. erase(header,z,info)：删除z节点
    用y记录z，定义节点x，先不赋初值，z_left记录z的左子节点，z_right记录z的右子节点
    1. 如果z_left为空，则x赋值为z_right；否则若z_right为空，则x赋值为z_left，此时x一定不为空；否则z_left和z_right都非空，则更新y为minimum(z_right)，即z的后继节点，x赋值为y的右子节点
        定义x_parent，用于记录即将出现的x的父节点  
    2. 如果y不等于z，说明z具有两个子节点。首先令z_left和y进行连接，然后判断y是否等于z_right，如果不相等，则将z_right和y进行连接。将x_parent赋值为y的父节点并且将x和x_parent进行连接（如果x不为空记得回马枪）；如果y与z_right相等，则将x_parent赋值为z的父节点。最后将y和z_parent进行连接  
    3. 如果y等于z，则说明z至多只有一个子节点。首先将x_parent赋值为z_parent，然后将x和x_parent进行连接。
        此时应该维护leftmost和rightmost：如果z为leftmost，则z一定不存在左子节点。此时若右子节点也不存在，则将leftmost更新为z_parent，否则更新为minimum(z_right)；如果z为rightmost与之对称  
    4. 将info.x赋值为x，info.y赋值为y，info.parent赋值为x_parent，为删除后的平衡调整做准备
9. rebalance_after_erasure(header,z,info)：删除了z节点之后进行颜色修改操作，info里存有删除后的相关信息，如有必要则需要进行颜色的调整和树形的旋转：  
    首先我要说的是，这个函数非常的精髓，非常巧妙地对删除所有需要调整颜色和旋转树形的情况进行讨论。因此，有必要对删除过后可能出现的需要调整颜色和旋转树形的情况进行举例。设待删除节点为z，则情况如下：  
    1. z为红色且z至多只有一个子节点，则删除过后并不影响z的子节点所在的子树的黑色节点的个数，也不会出现两个父子节点为红色的情况，因为z为红色，则p的颜色一定为黑色
    2. z为黑色且z至多只有一个子节点，则删除后z的子树均缺少一个黑色节点，需要进行调整
    3. z为红色且z有两个节点，y为minimum(z_right)，若y为红色，则删除过后y取代z的位置，不会对z的子树的黑色节点的个数造成影响，无需调整；若y为黑色，则z的左子树和右子树的节点颜色完全错乱，需要进行调整
    4. z为黑色且z有两个节点，y为minimum(z_right)，若y为黑色，同3无需进行调整；若y为红色，则需要进行调整  
    至此，四种情况列举完毕。则可以对该函数的代码实现做具体解释：  
    首先定义new_z_color，为的是接住新的z的位置的节点的新颜色  
    1. 如果info.y和y不相等，则说明z具有两个子节点，因为z位置的节点发生了替换，因此用new_z_color接住info.y的颜色，并且将info.y的颜色赋值为z的颜色（这就统一了情况3和情况4，如果z和y颜色相同则该操作没有什么很大的影响；如果z和y的颜色不同，将y的颜色赋值为z则可以保证z_left子树部分黑色节点个数不变，只需调整info.x子树部分为黑色节点个数加1即可）
    2. 否则，说明z至多只有一个子节点且没有新节点顶替z的位置。则将new_z_color赋值为z的颜色
    3. 如果new_z_color的颜色为红色，对于第1点，对应于z为红色y为红色z为黑色y为红色的情况，前者无需进行调整操作，后者因为在第1点已经将y的颜色修改为z的颜色，则z_left子树部分无需调整且因为y是红色，所以y的子树部分也无需调整。因此不需要调整；对于第2点，对应于z为红色的情况，无需调整
    4. 如果new_z_color的颜色为黑色，对于第1点，对应于z为红色y为黑色以及z为黑色y为黑色的情况，y的子树部分都缺少一个黑色节点，需要调整；对于第2点，对应于z为黑色的情况，z的子树缺少一个黑色节点，需要调整。因此需要调整。
        仅仅通过一个变量就总结除了需要调整的情况，而且还修正了一些容易修正的调整情况这就是代码tricky的部分    
10.  rebalance_after_erasure_restore_invariants(header,x,x_parent)：x为info.x，x_parent为info.x_parent，需要对x节点子树部分作颜色调整和树形旋转：  
    1. 在while(1)循环内：接下里将x_parent称为p（退出循环后如果x存在则将x的颜色调整为黑色来保证x的子树的颜色会多出一个黑色节点）  
        1. 若p为header，则说明删除的是root节点，直接退出就好
        2. 如果x存在且x的颜色为红色，则直接退出循环就好，因为退出循环后会将x的颜色改为黑色，则保证了x的子树部分多出了一个黑色  
            接下来，说明x为空或者x的节点颜色为黑色（其实都是x的节点颜色为黑色，因为红黑色的null节点的颜色默认为黑色）则需要进行调整  
        3. 如果x为p的左子节点（注意，x可能为空，而且在进入到这个判断条件之后若x为空则x的兄弟节点一定不为空，因为若z为黑色，则p的另一个子节点一定存在，若y为黑色则y的兄弟节点也一定存在，这是红黑树的规则4，这就是红黑树的特性）：
            1. 设w为p的右子节点，此时w一定存在。如果w的颜色为红色，则将w的颜色调整为黑色，将p的颜色调整为红色，然后以p为左旋点对p和w进行左旋操作，左旋后更新w为p的右子节点。这一步的目的是使得x的兄弟节点为黑色，因此，若w的颜色本来就是黑色则无需进行这一步操作
            2. 若w的左子节点和右子节点均为黑色（为空或者存在且为黑色）：则将w的颜色改为红色，令x为p，p为G继续向上调整。向上调整之后，新的x，即为p若为红色则会退出while循环后修改为黑色，因此w的子树的颜色与原来一致，同时又为x的子树新增一个黑色节点，符合要求；若新的x为黑色则与原来删除前的条件一致，重复对x进行删除动作即可。将w变为红色最重要的目的在于，因为w的两个子树都是黑色的（为空或者存在且为黑色），而且由于原来z的子树上作为根节点的z被删掉了，因此少了一个黑色节点，w的子树的黑色节点个数就与x的黑色节点个数一样，少了一个。这样我们逐渐向上查询，直到找到一稞子树的根节点为红色，此时，这个根节点到达叶子节点的每条路径上的黑色节点都被删除前少了一个黑色节点，所以把该根节点的颜色调整为黑色即可完成平衡操作
            3. 若w的右子节点为黑色（为空或者存在且为黑色）且左子节点为红色：则将w的左子节点的颜色调整为黑色，w调整为红色，然后以w为右旋点对w和w的左子节点进行右旋操作，并且将w调整回p的右子节点。这样，w仍然为黑色且w的左子节点存在且为黑色，右子节点调成了红色。这一点主要是为了把w的右子节点调整成红色的，方便我们后续操作
            4. 第3点的调整不是必要的，如果w的右子节点是黑色才需要调整，如果w的右子节点本来就是红色那么就不需要调整了。
            5. 经过第3点和第4点之后，将w的颜色赋值为p的颜色，将p的颜色赋值为黑色，如果w的右子节点存在则将其赋值为黑色。最后以p为左旋点对p和w进行左旋操作。大功告成！这一点的意义在于，如果p为红色，则将p调整黑色之后x的子树部分的黑色节点个数加1，恢复正常；w又调整为红色，则w的子树部分黑色节点个数减1，与x子树持平；如果w的右子节点为存在则必为红色，将其调整为黑色后其子树部分黑色节点个数与原来一致。再经过一次左旋操作后，w称为新的被删除节点部分的子树的根节点，其左子节点为p，p的右子节点为w的原左子节点，一定为黑色，w的右子节点不变，此时，w的左右子树部分的节点颜色就都与原来保持一致了。衔接这一点刚开始的解释，如果p本来就为黑色，那么对其赋值黑色并没有什么区别  
        4. 如果x为p的右子节点，则于iii对称  
    2. 退出循环，如果x存在则将其颜色赋值为黑色  
11. 对删除操作的总结：删除操作是红黑树的最难的操作了我认为。其本质在于对于缺少了一个黑色节点的x的子树，如何恢复那个黑色节点。可以在x的兄弟节点w为黑色的前提下分为三种情况：如果w的左右子节点均为色节点则需要将w的颜色修改为红色，则此时x和w的颜色缺失情况相同，我们只需要继续向上调整直到新的x为红色，此时新的x即为旧的p，作为旧的x和w的父节点，将其调整为黑色后二者的颜色确实情况就都复原了；除了这种情况之外的所有情况，都说明w的左右子节点至少有一个为红色，此时我们可以”借“一个调整好的子树部分到x的新的兄弟节点部分，而”借“的关键就是以w为新的p，即以p作为左旋点进行左旋操作。而在调整之前，需要知道以w为新的p之后，如果w调整为红色而p调整为黑色，则x的子树部分颜色还原，而x的新的兄弟子树部分不是别人正是w的旧的左子节点，w的旧的右子节点需要具有比删除之前多一个的黑色节点。而由于红黑树的性质，w的旧的左子节点的黑色颜色个数与x本来就是一致的，我们只需要关注w的右子节点，如果让其的黑色节点颜色个数加1就可以了。因此出现了对w的右子节点的颜色的讨论：如果w的右子节点本来就是黑色，则其之下不存在黑色节点，需要通过以w为右旋点的右旋操作将w的左子节点变为新的w，w变为新的右子节点，辅以将w的左子节点调整为黑色和将w调整为红色的操作，右旋过后就出现了我们想要的情况，即w的右子节点为红色。因此，我们在进行了以p为左旋点的左旋操作之后就可以将w的右子节点调整为黑色来实现我们的宏伟蓝图—-删除操作  
12. 对删除操作的总结II：删除操作完美利用了红黑色的性质。在删除的过程中不仅最后成功的保证了规则3和规则4，还将红黑树的平衡性进行了很好的调整。最让我觉得耳目一新的点莫过于：当x为黑色节点进入删除操作的判断过程中后，由于红黑树的性质可以推断出其兄弟节点子树部分高度至少为2且至少有三个节点的部分。这简直就是完美地利用了规则4啊，原来的z是黑色，加上x也是黑色，因此w的子树部分至少有两个黑色。诸如这样的例子在删除操作里太多太多了，如果要说可以说很久很久，总而言之，红黑树的删除操作终于告一段落了（红黑树的删除源码我甚至是在vivado的工程文件里找到的，哭死，本来想把源码贴上来的，因为实在是太经典了，但是手贱把文件关掉了。删除操作过程我记录得很详细了，其他操作记录得也很详细了，要想水平提高，必须摆脱经典源码，coding出自己的代码，冲！）  