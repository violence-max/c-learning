> 被const修饰的东西具有只读的特点
> 
1. 修饰变量：只读变量
2. 修饰对象：不能修改成员变量的值，不能调用非const函数  
    结合第9点，若使用const修饰一个对象，则该对象里的this指针是一个指向const对象的const指针，因此不能修改成员变量的值。而非const成员行数要求隐性传入的this指针是一个指向对象的const指针，这里发生了参数不匹配的问题，因此不能调用  
3. 指向const变量的指针：指针指向的是拥有const变量的地址，指向内容不可变，指向可变（`const int* p` ，p可以不断调整，即改变指向，但*p不能调整，即不能通过指针来改变const变量）  
    编译器是通过静态判断指针类型来识别指针是否为指向const变量的指针的，即即使指向const变量的指针指向乐一个非const变量的地址，也不可以通过引用指针的方式对该变量进行修改，而若用一个普通指针指向一个const变量的地址，则可以通过引用指针的方式对该变量进行修改，但是，该const变量会根据编译器的优化程度决定其值是否发生改变，在一些较低版本的编译器上有可能该值会发生改变。  
    因此，尽量使用const变量来替代宏定义来定义变量：使用const定义变量可以让编译器帮我们进行类型检查，而且在引用变量时会直接用const变量进行替换，并不会发生一次变量访问，即和宏定义一样具有相同的执行效率  
4. const指针：指向内容可变，指向不可变（`int * const p` ，p的指向一旦赋值不能发生改变）
5. 指向const变量的const指针：指向内容不可变，指向也不可变（const int * const p）
6. const变量做函数参数：函数内部不能改变此参数
7. const作为函数返回值：返回const引用
8. const作为类的成员变量：必须在初始化列表初始化，之后不能改变；静态const成员变量需要在类外单独初始化
9. const成员函数：不能修改任何成员变量（传给const成员函数的this指针是指向const对象的const指针）  
    在一个对象里面，一个this指针被隐形地当作参数传递给行数，而这个this指针是一个指向对象地const指针，其指向不能发生改变。而传递给const成员行数地this指针是一个指向const对象的const指针，因此不能够对成员变量进行修改  
[reference](https://zhuanlan.zhihu.com/p/90720012)