> heap不属于stl的容器组件，它是priority_queue的底层
>   
对于priority_queue底层选取的分析：  
其实优先队列的底层也可以选取双向链表作为其底层，这样就可以拥有插入和删除时O(1)的时间复杂度了。但是，根据优先队列的特性，需要每次取数时该数都是极值，然而通过双向链表取极值的时间复杂度是线性的。当然，如果控制双向链表插入时就是排好序的，优先队列的取极值和删除操作都会是最优的，但是插入却变成线性时间复杂度了。  
有一种比较爽的做法是使用二叉平衡搜索树当作是优先队列的底层，这样元素的插入和取极值的操作都会是O(log(n))。但是二叉平衡搜索树的输入需要一定的随机性以及并不是很容易实现。  
heap这种数据结构的复杂度刚好就介于list和binary search tree之间，适合用作优先队列的底层  
有关于heap的算法：  
1. push_heap()算法：就是常规的插入元素后调整堆的操作
2. pop_heap()算法：这个比较有趣，将堆顶元素放置进底层vector容器的最尾部，然后重新调整除了尾部元素的部分。算法流程大致是：从根节点开始，根据堆的特性（小顶堆或者大顶堆）重新从子节点选取新的根节点，然后从被选取的子节点的位置开始新的选取。但是这种做法会导致堆的完全二叉树的性质遭到破坏—除了最底层以外不允许有其它层是不满的。因此需要取出最底层最后的元素来充当最后被选取的子节点并且有必要重新调整堆
3. sort_heap()算法：经典的堆排序算法，通过每次将堆顶元素放置到尾部来实现一个递增序列或者递减序列（分别对应大顶堆和小顶堆）
4. make_heap()算法：建堆算法